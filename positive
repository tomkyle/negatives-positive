#!/usr/bin/env bash

# *******************************************************
#
#  positive
#
#  Author: Carsten Witt <tomkyle@posteo.de>
#  Homepage: <https://github.com/tomkyle/negatives-positive>
#
#  ImageMagick:
#  http://www.imagemagick.org/script/mogrify.php
#  http://www.imagemagick.org/script/convert.php
#
#  GNU Parallel:
#  https://www.gnu.org/software/parallel/
#
# *******************************************************


# ======================================
# Runtime Environment
# ======================================

set -o errexit  # Exit if any statement returns a non-true return value.
set -o nounset  # Exit if trying to use an uninitialised variable
set -o pipefail # Pipelines produce failure return code if any command errors.
# set -o xtrace


# --------------------------------------
# User settings:
# These settings can be set with command line arguments.
# --------------------------------------

declare -i BATCH_MODE=0
declare -i normalize_colors=0
declare gamma="${GAMMA_DEFAULT}"
declare output_directory="${PWD}"
declare -i desaturate_colors=0
declare -i verbous_mode=0
declare -i sigmoidal_contrast=0
declare -i resize_image=0
declare -i jpeg_quality=0
declare flipflop_positive=""

# --------------------------------------
# Global settings
# --------------------------------------

# Files to work on
# The regex shown here must be suitable for regex find'ing:
# -iregex '.*\.(tif|tiff)'
declare SEARCH_FILES_IREGEX='.*\.(tif|tiff)'

# Where to search
declare SEARCH_DIRECTORY="."

# --------------------------------------
# Immutables
# --------------------------------------

# List of possible script arguments (getopts)
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
readonly OPTIONS_LIST=""


# Internal Field Separator
### While this is recommended in "best-practice tutorials",
### this breaks calling dcraw and mogrify. Better let this commented-out.
readonly DEFAULT_IFS="${IFS}"
readonly SAFER_IFS=$'\n\t'
#IFS="${SAFER_IFS}"


# Filesystem basics
readonly SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
readonly SCRIPT_NAME=$(basename $0)


# Consistent package location
readonly HOMEBREW_OPT_DIR=$(brew --prefix $(basename $0))
# Hack for development purposes
# HOMEBREW_OPT_DIR=$SCRIPT_DIR


# Prepare (but not create) a new temp directory
readonly WORK_TMPDIR=$(mktemp -du "${TMPDIR:-/tmp/}$(basename 0).XXXXXXXXXXXX")  || { e_error "Failed to create temp directory name."; }


# Formatting stuff
readonly DIVIDER_LINE="------------------------------------------"
readonly C_WHITE='\033[1;37m'
readonly C_RED='\033[0;31m'
readonly C_GREEN='\033[0;32m'
readonly C_BLUE='\033[1;34m'
readonly NC='\033[0m' # No Color


# Informative files
readonly LICENSE_FILE="LICENSE"
readonly USAGE_FILE="USAGE"
readonly CREDITS_FILE="CREDITS"

# --------------------------------------
# Output and formatting functions
# --------------------------------------

# ======================================
#  The main program
# ======================================

function main {

  function exit_err {
    echo >&2 "${@}"; exit 1;
  }

  function require  {
    command -v $1 >/dev/null 2>&1 || exit_err "Program '${1}' required, but it's not installed";
  }


  # --------------------------------------
  # Requirements
  # --------------------------------------

  # Homebrew dependencies
  require mogrify
  require convert
  require parallel
  require color-profiles

  # System commands
  require getconf
  require brew
  require dirname
  require basename
  require getopts
  require awk




  # --------------------------------------
  # The result suffix
  # --------------------------------------

  # To be appended to output file names
  RESULT_SUFFIX=""
  RESULT_SUFFIX_DEFAULT="-positive"

  # Enable or disable RESULT_SUFFIX.
  # 1: enabled (default)
  # 0: disabled
  APPEND_RESULT_SUFFIX=1


  # --------------------------------------
  # Output contrast settings
  # --------------------------------------

  # Default Gamma value
  GAMMA_DEFAULT=1


  # Percentage of histogram edges to be truncated.
  # The default is that 0.1 percent of the histogram entries are ignored.
  # Set to 0 to use the complete histogram.
  HISTOGRAM_THRESHOLD=0.1


  # --------------------------------------
  # Pathes to ICC profiles
  # --------------------------------------

  # Linear Gamma 1.0 Gray profile
  # Applied when output is converted to Grayscale
  GRAY_ICC_PROFILE_PATH=$(color-profiles gray-linear )

  # ICC's sRGB v4 Appearance profile
  # Applied when output is converted to JPEG
  SRGB_APPEARANCE_ICC_PROFILE_PATH=$(color-profiles srgb-v4 )



  # ======================================
  #  Script parameter handling
  # ======================================


  # --------------------------------------
  # Output small doc if no parameter given
  # --------------------------------------
  if [ "$#" -eq 0 ]; then
    if [ -f "${HOMEBREW_OPT_DIR}/${USAGE_FILE}" ]; then
      cat "${HOMEBREW_OPT_DIR}/${USAGE_FILE}"
    else
      cat "${SCRIPT_DIR}/${USAGE_FILE}"
    fi

    echo;
    if [ -f "${HOMEBREW_OPT_DIR}/${CREDITS_FILE}" ]; then
      cat "${HOMEBREW_OPT_DIR}/${CREDITS_FILE}"
    else
      cat "${SCRIPT_DIR}/${CREDITS_FILE}"
    fi
    echo;
    exit 1;
  fi


  # --------------------------------------
  # Parse parameters
  # --------------------------------------

  while getopts adnf:j:g:o:c:r:s:v option
  do
    case "${option}"
    in
      a)  BATCH_MODE=1;;
      d)  desaturate_colors=1;;
      n)  normalize_colors=1;;
      f)  flipflop_positive="${OPTARG}";;
      j)  jpeg_quality="${OPTARG}";;
      g)  gamma="${OPTARG}";;
      o)  output_directory=${OPTARG};;
      r)  resize_image=${OPTARG};;
      s)  sigmoidal_contrast=${OPTARG};;
      v)  verbous_mode=1;;
      *)  exit_err "Unknown option used. Run ${SCRIPT_NAME} without parameters to get a list of all options."
          ;;
    esac
  done

  shift $(( OPTIND - 1 ));




  # ======================================
  #  Batch processing: parameter -a
  # ======================================
  if [ $BATCH_MODE -eq  1 ]; then

    echo $DIVIDER_LINE

    # ---------------------------------------
    # The TODO-File in temp directory
    # ---------------------------------------
    #WORK_TMPDIR=$(mktemp -d "${TMPDIR:-/tmp/}$(basename 0).XXXXXXXXXXXX")  || { exit_err "Failed to create temp directory"; }
    TODO_TXT="${WORK_TMPDIR}/positive-todo.txt"
    >"${TODO_TXT}"

    START_TIME=$SECONDS


    # ---------------------------------------
    # Find Files to process
    # ---------------------------------------
    find -E "${SEARCH_DIRECTORY}" -maxdepth 1 -type f -iregex "${SEARCH_FILES_IREGEX}" > "${TODO_TXT}"
    NUMOFIMAGES=$(cat "${TODO_TXT}" | wc -l | sed -e 's/^[ \t]*//')


    # ---------------------------------------
    # Print some information
    # ---------------------------------------
    if [ $verbous_mode -eq 1 ]; then
      printf "${C_BLUE}Files to process:${NC}\n"
      cat "${TODO_TXT}"
      echo;
    fi


    # ---------------------------------------
    # Build param string for recursive calls
    # ---------------------------------------
    PARAMS=""
    if [ "${gamma}" != "${GAMMA_DEFAULT}" ]; then PARAMS="${PARAMS} -g ${gamma}"; fi
    if [ ! -z "${flipflop_positive}" ]; then PARAMS="${PARAMS} -f ${flipflop_positive}"; fi
    if [ "${output_directory}" != "${PWD}" ]; then PARAMS="${PARAMS} -o ${output_directory}"; fi
    if [ $sigmoidal_contrast -gt 0 ]; then PARAMS="${PARAMS} -s ${sigmoidal_contrast}"; fi
    if [ $normalize_colors -eq 1 ]; then PARAMS="${PARAMS} -n"; fi
    if [ $desaturate_colors -eq 1 ]; then PARAMS="${PARAMS} -d"; fi
    if [ $jpeg_quality -gt 0 ]; then PARAMS="${PARAMS} -j ${jpeg_quality}"; fi
    if [ $resize_image -gt 0 ]; then PARAMS="${PARAMS} -r ${resize_image}"; fi
    if [ $verbous_mode -gt 0 ]; then PARAMS="${PARAMS} -v"; fi


    # ---------------------------------------
    # Start parallel processing
    # ---------------------------------------
    printf "${C_BLUE}Process ${NUMOFIMAGES} images, using GNU Parallel:${NC}\n"
    echo;

    cat "${TODO_TXT}" | parallel "$0" $PARAMS {}


    # ---------------------------------------
    # Some stats
    # ---------------------------------------
    CPUs=$(getconf _NPROCESSORS_ONLN)
    ELAPSED_TIME=$(($SECONDS - $START_TIME))


    # ---------------------------------------
    # Remove crap
    # ---------------------------------------
    rm -Rf "${WORK_TMPDIR}"


    # ---------------------------------------
    # Write outro
    # ---------------------------------------
    echo $DIVIDER_LINE
    printf "${C_BLUE}Some stats:${NC}\n"
    echo "CPUs used:        ${CPUs}"
    echo "Elapsed time:     $(($ELAPSED_TIME/60))min $(($ELAPSED_TIME%60))sec"
    echo "Done:             ${NUMOFIMAGES} images"

    unset require TODO_TXT SEARCH_FILES_IREGEX ELAPSED_TIME START_TIME NUMOFIMAGES CPUs RUN_MODE LINES IMAGE resize_image;




  # ======================================
  #  No batch mode: process file(s)
  # ======================================
  else


    # ---------------------------------------
    #  Build mogrify's options string:
    #  We'll start with color inversion (negate) and horizontal flip (flop).
    #  See:
    #  http://www.graphicsmagick.org/GraphicsMagick.html#details-negate
    #  http://www.graphicsmagick.org/GraphicsMagick.html#details-flop
    # ---------------------------------------
    OPTIONS="-negate"


    # ---------------------------------------
    # Flip or flop the image, if required.
    # ---------------------------------------
    if [ ! -z "${flipflop_positive}" ]; then
      OPTIONS="${OPTIONS} -${flipflop_positive}"
    fi


    # ---------------------------------------
    # Resize image on its larger side
    # ---------------------------------------
    if [ $resize_image -gt 0 ]; then
      OPTIONS="${OPTIONS} -resize ${resize_image}x${resize_image}>"
    fi


    # ---------------------------------------
    #  Normalize colors, if required:
    #  Transform image to span the full range of color values
    #
    #  See http://www.graphicsmagick.org/GraphicsMagick.html#details-normalize
    # ---------------------------------------

    if [ $normalize_colors -eq 1 ]; then
      OPTIONS="${OPTIONS} -set histogram-threshold ${HISTOGRAM_THRESHOLD} -normalize";
    fi



    # ---------------------------------------
    #  Apply Sigmoidal Contrast Curve.
    #  Increases the contrast without saturating highlights or shadows.
    # ---------------------------------------

    if [ $sigmoidal_contrast -gt 0 ]; then
      OPTIONS="${OPTIONS} -sigmoidal-contrast ${sigmoidal_contrast},50%";

      # Append to suffix
      RESULT_SUFFIX="${RESULT_SUFFIX}-s${sigmoidal_contrast}"
    fi



    # ---------------------------------------
    #  Apply Gamma, if required.
    #  Having colors normalized with -n parameter
    #  is heavily recommended.
    # ---------------------------------------

    if [ "${gamma}" != "${GAMMA_DEFAULT}" ]; then
      GAMMA_VALUE=`echo "1 ${gamma}" | LC_NUMERIC=en_US.utf-8 awk --use-lc-numeric '{printf "%0.2f", $1 / $2}'`
      OPTIONS="${OPTIONS} -gamma ${GAMMA_VALUE}";

      # Append to suffix
      RESULT_SUFFIX="${RESULT_SUFFIX}-g${gamma/./}"
    fi





    # ---------------------------------------
    #  Desaturate colors, if required.
    #  Also convert to Grayscale with ICC profile embedded.
    #  Equivalent to ImageMagick's "-grayscale rec709luma"
    #  See http://www.graphicsmagick.org/GraphicsMagick.html#details-modulate
    # ---------------------------------------

    if [ $desaturate_colors -eq 1 ]; then
      OPTIONS="${OPTIONS} -modulate 100,0 -colorspace Gray -profile ${GRAY_ICC_PROFILE_PATH}"
    fi



    # ---------------------------------------
    #  Compress image
    # ---------------------------------------
    OPTIONS="${OPTIONS} -compress Zip "



    # ---------------------------------------
    # Create output directory if needed.
    # ---------------------------------------
    if [ "${output_directory}" != "${PWD}" ]; then
      mkdir -p "${output_directory}";
    fi;


    # ---------------------------------------
    # Reset result suffix,
    # if disabled somewhere above.
    # Set to default value, if target directory
    # is identical with $PWD
    # ---------------------------------------

    # Reset if generally disabled

    if [ $APPEND_RESULT_SUFFIX -eq 0 ]; then
      RESULT_SUFFIX=""
    fi;


    # When target directory is $PWD,
    # duplicate files must be avoided
    if [ "${output_directory}" = "${PWD}" ]; then

      # If result suffix is empty, assume default value.
      if [ -z "${RESULT_SUFFIX}" ]; then
        RESULT_SUFFIX="${RESULT_SUFFIX_DEFAULT}"
      fi;
    fi;



    # =============================================================
    #  The Loop: Process each file given
    # =============================================================

    for INPUT_FILE in "$@"
    do

      # ---------------------------------------
      #  If $INPUT_FILE is regular file
      # ---------------------------------------

      if [ -f "${INPUT_FILE}" ]; then

        echo $DIVIDER_LINE
        printf "${C_WHITE}${INPUT_FILE}${NC}\n"


        # ---------------------------------------
        # Filename magic
        # ---------------------------------------
        INPUT_FILE_EXTENSION="${INPUT_FILE##*.}";
        INPUT_FILE_BASENAME="${INPUT_FILE%.$INPUT_FILE_EXTENSION}"
        INPUT_FILE_BASENAME="${INPUT_FILE_BASENAME##*/}" # remove trailing slash

        OUTPUT_FILE="${output_directory}/${INPUT_FILE_BASENAME}${RESULT_SUFFIX}.${INPUT_FILE_EXTENSION}"
        OUTPUT_FILE_JPEG="${output_directory}/${INPUT_FILE_BASENAME}${RESULT_SUFFIX}.jpg"

        # Create workfile to work on with mogrify
        cp "${INPUT_FILE}" "${OUTPUT_FILE}"



        # ---------------------------------------
        #  Go!
        # ---------------------------------------
        if [ $verbous_mode -gt 0 ]; then echo; fi
        printf "Create positive image: "

        if [ $verbous_mode -eq 1 ]; then
          printf "\nmogrify ${OPTIONS}\n..."
        fi

        mogrify ${OPTIONS} "${OUTPUT_FILE}" && echo "Done."




        # ---------------------------------------
        #  Save as JPEG, if required
        # ---------------------------------------

        if [ $jpeg_quality -gt 0 ]; then
          if [ $verbous_mode -gt 0 ]; then echo; fi
          printf "Convert to JPG (sRGB; quality ${jpeg_quality}): "

          # JPG quality
          CONVERT_OPTIONS=" -quality ${jpeg_quality}"
          # Convert to sRGB
          CONVERT_OPTIONS="${CONVERT_OPTIONS} -colorspace sRGB -profile ${SRGB_APPEARANCE_ICC_PROFILE_PATH}"

          if [ $verbous_mode -gt 0 ]; then printf "\nconvert ${CONVERT_OPTIONS}\n..."; fi

          convert "${OUTPUT_FILE}" ${CONVERT_OPTIONS} "${OUTPUT_FILE_JPEG}" \
          && rm "${OUTPUT_FILE}" \
          && echo "Done."

          printf "Result: ${C_GREEN}${OUTPUT_FILE_JPEG}${NC}\n"


        else
          # ---------------------------------------
          #  No JPEG compression
          # ---------------------------------------

          if [ -f "${OUTPUT_FILE}" ]; then
            printf "Result: ${C_GREEN}${OUTPUT_FILE}${NC}\n"
          fi;

        fi



      # ---------------------------------------
      #  $INPUT_FILE is NOT a regular file
      # ---------------------------------------
      else
        printf "${C_RED}${INPUT_FILE} is not a regular file.${NC}\n"
      fi;

      # screen readability
      echo;
    done

  fi;

  exit 0

}

main "$@"
